

    /**
    * @param root a given BST
    * @return check is valid BST
    * DfS: O(logn)
    * dfs(root, Integer l, Integer r)
    * if(l !=null && root.val <= l)return false
    * return dfs(ro.l, l, ro.val) && dfs(ro.r, ro.val, r)
    * 
    * Iteration: O(n)
    * BST: all left small than root, root small than right-> Inorder traversal
    * set a preNode = null and currNode as pointer
    * using stack as temp storage, top is the smallest
    * push all left node to stack
    * temp pop()  is the parent of preNode
    * assign preNode = temp; curr = curr.right;
    **/
public class Solution {    
   public boolean isValidBST(TreeNode root) {
        return dfs(root, null, null);
    }
    
    public boolean dfs(TreeNode root, Integer leftbound, Integer rightbound){
        if(root == null) return true;
        
        if(leftbound != null && root.val <= leftbound){
            return false;
        }
        if (rightbound != null && root.val >= rightbound){
            return false;
        }
        return dfs(root.left, leftbound,root.val) && dfs(root.right, root.val, rightbound);
    }
    /*
    public boolean isValidBST(TreeNode root) {
        TreeNode currNode = root;
        TreeNode preNode = null;
        Stack<TreeNode> stack = new Stack<>();
        
        while(currNode != null || !stack.isEmpty()){
            while(currNode != null){
                stack.push(currNode);
                currNode = currNode.left;
            }
            TreeNode temp = stack.pop();
            if(preNode != null && temp.val <= preNode.val){
                return false;
            }
            preNode = temp;
            currNode = temp.right;
        }
        return true;
    }*/
    
    
}
