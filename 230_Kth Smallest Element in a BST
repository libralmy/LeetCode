     /**
     * BST is sorted inorder traversal tree
     * so using Binary Search
     * count left sub treenode
     * if k<= count => search in left tree, else k-1-count in right tree
     * k = count +1 is the root value need to be returned**/
public class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int count = countLeftNode(root.left);
        
        if(k <= count){
            return kthSmallest(root.left, k);
        }else if(k > count+1){
            return kthSmallest(root.right, k-1-count);
        }
        
        return root.val;
        
    }
    
    public int countLeftNode(TreeNode left){
        if(left == null) return 0;
        return 1 + countLeftNode(left.left) + countLeftNode(left.right);
    }
    
    
    /**using stack **/
    /*
      public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> st = new Stack<>();
        
        while (root != null) {
            st.push(root);
            root = root.left;
        }
            
        while (k != 0) {
            TreeNode n = st.pop();
            k--;
            if (k == 0) return n.val;
            TreeNode right = n.right;
            while (right != null) {
                st.push(right);
                right = right.left;
            }
        }
        
        return -1; // never hit if k is valid
  }
    */

}
